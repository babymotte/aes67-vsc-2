/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_AES67_VSC_2__
#define __RUST_AES67_VSC_2__

static const unsigned int AES_VSC_OK = 0x00;
static const unsigned int AES_VSC_ERROR_NOT_INITIALIZED = 0x01;
static const unsigned int AES_VSC_ERROR_ALREADY_INITIALIZED = 0x02;
static const unsigned int AES_VSC_ERROR_UNSUPPORTED_BIT_DEPTH = 0x03;
static const unsigned int AES_VSC_ERROR_UNSUPPORTED_SAMPLE_RATE = 0x04;
static const unsigned int AES_VSC_ERROR_VSC_NOT_CREATED = 0x05;
static const unsigned int AES_VSC_ERROR_RECEIVER_NOT_FOUND = 0x06;
static const unsigned int AES_VSC_ERROR_SENDER_NOT_FOUND = 0x07;
static const unsigned int AES_VSC_ERROR_INVALID_CHANNEL = 0x08;
static const unsigned int AES_VSC_ERROR_RECEIVER_BUFFER_UNDERRUN = 0x09;
static const unsigned int AES_VSC_ERROR_CLOCK_SYNC_ERROR = 0x0A;
static const unsigned int AES_VSC_ERROR_RECEIVER_NOT_READY_YET = 0x0B;
static const unsigned int AES_VSC_ERROR_NO_DATA = 0x0C;

#ifdef __cplusplus
extern "C" {
#endif

/** \brief
 *  Configuration for an AES67 receiver
 */
typedef struct Aes67VscReceiverConfig {
    /** \brief
     *  Name of the receiver. Technically this does not have to be unique but stats are reported by receiver name,
     *  so giving the same name to multiple receivers at the same time will make those hard to interpret.
     */
    char const * name;

    /** \brief
     *  The content of the SDP file of the sender that this receiver should subscribe to.
     */
    char const * sdp;

    /** \brief
     *  Link offset in milliseconds
     */
    float link_offset;

    /** \brief
     *  String representation of an IP address (e.g. "192.168.1.123") that is assigned to the network interface
     *  this receiver should bind to.
     */
    char const * interface_ip;
} Aes67VscReceiverConfig_t;


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  Create a new AES67 receiver
 *  * `config` - the configuration for the sender
 */
int32_t
aes67_vsc_create_receiver (
    Aes67VscReceiverConfig_t const * config);

/** \brief
 *  Destroy an existing AES67 receiver. Destroying a receiver will stop it from receiving any
 *  more audio packets and filling the assigned buffer. It will also de-allocate any memory the
 *  receiver has allocated during its creation.
 *
 *  * `receiver_id` - the ID of the receiver to be destroyed
 */
uint8_t
aes67_vsc_destroy_receiver (
    uint32_t receiver_id);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_float {
    /** \brief
     *  Pointer to the first element (if any).
     */
    float * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_float_t;

/** \brief
 *  Fetch data from the specified receiver
 *
 *  * `receiver_id` - the receiver id as returned by the `aes67_vsc_create_receiver` function
 *  * `playout_time` - the media clock timestamp of the first frame to fetch
 *  * `buffer_ptr` - pointer to a float[] to which the fetched audio samples will be written
 */
uint8_t
aes67_vsc_receive (
    uint32_t receiver_id,
    uint64_t playout_time,
    slice_mut_float_t buffer_ptr);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_AES67_VSC_2__ */
